// pulp project pulp.go
package pulp

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/core/http"
	"github.com/Azure/azure-sdk-for-go/core/tls"
	"io"
	"io/ioutil"
	"strconv"
)

type ContentUnitCounts struct {
	DockerBlob     int `json:"docker_blob"`
	DockerImage    int `json:"docker_image"`
	DockerManifest int `json:"docker_manifest"`
}

type Id struct {
	Oid string `json:"$oid"`
}

type Note struct {
	RepoType string `json:"_repo-type"`
}

type Filters struct {
	Unit        string `json:"unit"`
	Association string `json:"association"`
}

type ErrorDetail struct {
	description string `json: "description"`
}

type ErrorResponse struct {
	Code        string      `json: "http_status"`
	ErrorDetail ErrorDetail `json: "error"`
}

type pulpResponse struct {
	status  int
	headers http.Header
	body    []byte
}

type Client struct {
	Endpoint string
	Cert     Certificate
	UserName string //credentials to use
	Password string //if certificate auth is not being used
}

type Certificate struct {
	PkiCertificate string `json:"certificate"` //Certificate given back by pulp
	PkiKey         string `json:"key"`
}

type RepositoryDetails struct {
	URL             string            `json:"_href"`
	PulpId          Id                `json:"_id"`
	Ns              string            `json:"_ns"`
	Description     string            `json:"description"`
	Display         string            `json:"display_name"`
	RepoId          string            `json:"id"`
	LastUnitAdded   string            `json:"last_unit_added"`
	LastUnitRemoved string            `json:"last_unit_removed"`
	Notes           Note              `json:"notes"`
	UnitCounts      ContentUnitCounts `json:"content_unit_counts"`
}

type Repositories []RepositoryDetails

func NewClient(endpoint, pkicert, pkikey, username, password string) *Client {
	client := &Client{
		Endpoint: endpoint,
		UserName: username,
		Password: password,
		Cert: Certificate{
			PkiCertificate: pkicert,
			PkiKey:         pkikey,
		},
	}

	return client
}

// Format of reply when http error code is not 200.
// Format may be:
// {"error": "reason"}
// {"error": {"param": "reason"}}
//type requestError struct {
//	Error interface{} `json:"error"` // Description of this error.
//}

func (client *Client) GetRepositories() (Repositories, error) {
	var pulpresponse *pulpResponse
	var err error
	var repository Repositories
	if pulpresponse, err = execute("GET", "/pulp/api/v2/repositories/", nil, nil, client.Endpoint, client.UserName, client.Password); err != nil {
		return nil, err
	}

	marshalError := json.Unmarshal(pulpresponse.body, &repository)
	if marshalError != nil {
		return nil, marshalError
	}

	return repository, nil
}

func (client *Client) Authenticate() error {
	//var body []byte
	var cert Certificate
	var pulpresponse *pulpResponse
	fmt.Println("endpoint: " + client.Endpoint)
	var err error
	if pulpresponse, err = execute("POST", "/pulp/api/v2/actions/login/", nil, nil, client.Endpoint, client.UserName, client.Password); err != nil {
		return err
	}

	if err = json.Unmarshal(pulpresponse.body, &cert); err != nil {
		return err
	}
	client.Cert = cert

	return nil
}

// Error - all errors generated by HTTP transactions are of this type.
// Other error may be passed on from library functions though.
type Error struct {
	StatusCode int // HTTP status code
	Text       string
}

// Error satisfy the error interface.
func (e *Error) Error() string {
	return e.Text
}

// newError make a new error from a string.
func newError(StatusCode int, Text string) *Error {
	return &Error{
		StatusCode: StatusCode,
		Text:       Text,
	}
}

// newErrorf makes a new error from sprintf parameters.
func newErrorf(StatusCode int, Text string, Parameters ...interface{}) *Error {
	return newError(StatusCode, fmt.Sprintf(Text, Parameters...))
}

//this is for error response. need to merge this with regular call
func getResponse(r *http.Response) ([]byte, error) {
	var e requestError
	var b []byte
	var err error

	if b, err = ioutil.ReadAll(r.Body); err != nil {
		return nil, err
	}
	if r.StatusCode == http.StatusOK {
		return b, nil
	}
	if err = json.Unmarshal(b, &e); err == nil {
		switch v := e.Error.(type) {
		case string:
			return nil, newErrorf(r.StatusCode, "%s", v)
		case map[string]interface{}:
			for param, reason := range v {
				if reasonstr, ok := reason.(string); ok {
					return nil, newErrorf(r.StatusCode, "%s: %s", param, reasonstr)
				}
			}
			return nil, newErrorf(r.StatusCode, "wrong parameter")
		}
	}
	return nil, newErrorf(r.StatusCode, "unexpected HTTP status code %d", r.StatusCode)
}

func errorFromJson(body []byte, code int) (*ErrorResponse, error) {
	var responseError *ErrorResponse
	if err := json.Unmarshal(body, responseError); err != nil {
		return responseError, err
	}
	responseError.Code = strconv.Itoa(code)
	return responseError, nil
}

func execute(verb, url string, headers map[string]string, content io.Reader, endPoint, userName, password string) (*pulpResponse, error) {

	transport := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	defaultClient := &http.Client{Transport: transport}
	request, err := http.NewRequest(verb, endPoint+url, content)

	if err != nil {
		return nil, err
	}
	request.SetBasicAuth(userName, password)
	response, err := defaultClient.Do(request)

	if err != nil {
		return nil, err
	}

	defer response.Body.Close()

	statusCode := response.StatusCode
	if statusCode >= 400 && statusCode <= 505 {
		var responseBody []byte
		responseBody, err = getResponse(response)
		if err != nil {
			return nil, err
		}
		fmt.Print(responseBody)
		if len(responseBody) == 0 {
			// no error in response body
			err = fmt.Errorf("pulp: service returned without a response body (%s)", response.Status)
		} else {
			// response contains storage service error object, unmarshal
			errorResponse, errIn := errorFromJson(responseBody, response.StatusCode)
			if err != nil { // error unmarshaling the error response
				err = errIn
			}
			err = errorResponse
		}
		return &pulpResponse{
			status:  response.StatusCode,
			headers: response.Header,
			body:    responseBody,
		}, err
	}

	var responseBody []byte
	responseBody, err = getResponse(response)
	if err != nil {
		return nil, err
	}
	fmt.Print(response.Status)
	return &pulpResponse{
		status:  response.StatusCode,
		headers: response.Header,
		body:    responseBody,
	}, nil

	return nil, nil
}
func (e *ErrorResponse) Error() string {
	return fmt.Sprintf("storage: service returned error: Code=%s, ErrorMessage=%s", e.Code, e.ErrorDetail.description)
}
